（线性结构：有唯一第一个元素和最后元素，有唯一前驱（除第一个元素）、唯一后继（除最后元素））

（非线性结构：<font style="color:rgb(77, 77, 77);">各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。这就是所谓的</font>**<font style="color:#DF2A3F;">一对多或者多对一</font>**<font style="color:rgb(77, 77, 77);">，总之不是一对一。</font>）

<h1 id="Z9enP">注意</h1>
<h2 id="oeLVj">区分：线性表 是一种逻辑结构，顺序表 和 链表 是存储结构，他们是 线性表 的一种 </h2>


<h2 id="Qyh5r">比对：顺序存取 ， 顺序存储 ， 随机存取 ， 随机存储（链式存储）</h2>


<h3 id="O2r84">顺序存取  ：直接存取，存 和 取 数据与存储位置无关，可以直接存取</h3>
<h3 id="E429t">随机存取 ：存 / 取 第N个数据时，必须先访问前N-1个数据。</h3>


<h3 id="UuyAZ">顺序存储 ：逻辑上相邻的元素在物理位置上也相邻；</h3>
<h3 id="yiFwL">随机存储（链式存储）：存储单元可以连续也可以不连续</h3>


<h1 id="YlVtA">线性表（逻辑结构）</h1>
<h2 id="QdEXi">顺序表（存储结构：顺序存储）：</h2>
用一组连续的地址空间存储线性表中的数据元素；

<h3 id="KX0rr">特点：</h3>
<h4 id="Q6ehQ">逻辑顺序与物理顺序相同</h4>
<h4 id="CnZSs">随机访问（通过首地址和元素序号可在O（1）内找到指定元素）</h4>
<h4 id="skRvn">存储密度高（节点只存数据元素）</h4>
<h4 id="VnoRy">插入和删除需要移动大量元素（查找快，更新耗费大） 	</h4>


<h3 id="deGaF"><font style="color:#ED740C;">综合应用题：   
</font></h3>
+ **逆置整个线性表（要求空间复杂度为O（1））：关键词（循环左移/右移）**
    - 两个指针(i和j)，一个指开头（i）一个指结尾(j)，指向的元素互换（需要一个空间），然后指针向中间靠，直到i>=j结束。（时间复杂度O（n））
    - -》引申题：
    - 将n个整数存放到一维数组R中，设计一个在时间和空间方面都尽可能高效的算法，将R中保存的序列循环左移p（0<p<n）个位置，即将R中的数据由（x0,x1,...xn-1）变换为（xp,xp+1,..............,xn-1,x0,x1,...,xp-1）：
        * 显然是逆置的做法
+ **删除特定某些值（可以用等于，大于,小于某个特定值来区分出来），且时间复杂度O（N）：**
    - 有序和无序：声明k为已经检测出的符合条件的这些值的数目，从下界检测到上界（大于/小于关系的，其界不一定是整个顺序表），若符合条件则k++，否则该元素前移k位（L.data[i-k]=L.data[i]）(时间复杂度O（n），空间O（1）)
+ **删除重复值：**
    - 有序：若表长为0则退出，表长为1直接结束；从第二个元素扫到最后一个元素，声明front记录前一个元素值，k为重复元素个数；每个元素与front比对，若相等则k++，不同则元素前移k位，front记录该不同的值；（时间复杂度O（n），空间O(1)）
    - 无序：构造哈希表（时间O（n），空间O（n））
+ **两个有序线性表合并为一个：**
    - 用两个指针指向两个表开头，比对两个指针指向的值，较小的元素放入新表，被使用的元素的指针指向下一个元素，另一个不动，直至其中一个表的元素都放到新表中；然后将剩下的表的元素按次序放到新表中；
+ **一维数组A[m+n]中顺序存放两个线性表（a1...am）,(b1...bn),要求将顺序换成(b1.....bn),(a1.....am):**

>     - 第一想法是两个指针分别指两个表开头，然后交换，但问题在于两个表长度可能不同；
>     - 第二想法是创建一个新表，先放b1-bn，再放a1-am,这样时间复杂度为O（m+n）,空间复杂度为O（m+n）
>

    - 但最优解显然是先对整个表逆置（a1...amb1...bn）->(bn...b1am...a1)，再分别对（bn...b1）和（am...a1）逆置（时间复杂度O（n）,空间复杂度O（1））
+ **递增顺序表中最短时间找某个特定值：二分查找（关键词：排好序，找某个值）**
    - mid = (low + high) /2
    - 判断L.data(mid)与x关系：若相等则停止；
    - 若mid>x，找mid左半部分，high = mid - 1(mid已经被排除了)；
    - 若mid < x，找mid右半部分，low = mid + 1（不包括mid）
    - 结束条件为low > high



    - 引申->
    - 一个长度为L（L>=1）的升序序列S，处在L/2（向上取整）（如1，2，3，4，5，显然5/2（向上取整），3为中位数；1，2，3，4取2）个位置的数称为S的中位数。现在有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。

>         * 第一想法：设k为已排序的元素数目，两者头部比较，先k++，然后较小者指针后移，当k = L/2（向上取整）时，较小者为中位数	（归并）
>

        * 最优解：（二分）找A和B中位数Am和Bm，比较他们的值：
            + 若Am=Bm，说明A和B归并后Am前面和Bm前面的元素（各L/2）会排在一起，Am与Bm紧挨在一起，因此Am或Bm就是中位数
            + 若Am<Bm,说明Am与Bm间的元素是中位数，因此去除Am前面的元素，Bm后面的元素（注意奇数和偶数的差别；1，2，3，4，取中位数2；因此偶数数组若要去除前面的元素，要包括上中位数）
            + 与上一个情况类似



PS:**只说时间上尽可能高效的话可以用空间换时间**

<h2 id="bXKpd">链表（存储结构）：</h2>
<h3 id="lUiXD">单链表：</h3>
通过一组任意的存储单元存储线性表中数据元素。每个链表节点除存放元素外，还要存储一个指向后继的指针。

<h4 id="NajYh">特点：</h4>
+ 浪费存储空间（还要多存放一个指针）
+ 非随机存取（顺序存取）结构，要找到第n个元素，需要经过前n-1个元素



通常用头指针标识一个链表,(单链表L,头指针为NULL时表示一个空表),为了操作方便会在第一个结点前附加一个结点,称为头结点



**头结点与头指针区分:**

**头指针:指向链表第一个结点**

**头结点:带头结点链表的第一个结点**

****

**头结点的好处:**

        1. **对链表第一个元素的操作和其他位置操作一致;**
        2. **统一空表和非空表处理(无论链表是否为空,其头指针指向一个非空指针)**

<h4 id="EAw39">操作:</h4>
+ 插入
    1. 头插法:插入新结点时在头结点尾部插入(将头结点后驱指向新结点,新结点后驱指向原来头结点后驱指向的结点)
    2. 尾插法:(需要**<font style="color:#DF2A3F;">新增一个指向尾部的指针</font>**(时间O(1),空间O(1))/或者每次都遍历一遍到尾部(时间O(n)))        修改尾部的指针后驱从指向NULL到指向新结点
+ 查找结点

```python
PS:LNode 是包含数据域和指针域的结构体;LinkList是LNode *的别名
LNode * GetElem(LinkList L,int i){
    int j = 1;//从第一个结点开始找
    LNode * p = L->next;	//头结点
    if (i == 0){return p}
    if(i<0){
        return NULL;
    }
    while(p&& i < j){
        p=p->next;
        j++;
    }
    return p;
}
```

```python
LNode * LocateElem(LinkList L,ElemType e){
    LNode *p = L->next;
    while(p){
        if(p->data != e){
            p = p->next;
        }
    }
    return p;
}
```

```python
//把值为x的结点插在第i个位置上
p = GetElem(L,i-1);

//还要判p是否为空，但这里就省略了，下同

s->next = p->next; 
p->next = s;
```

```python
/* 
知道某一结点位置p,在其前面插入的操作其实可以转化为后插:
将s插在其后,再交换数据域部分即可
*/

s->next = p->next; //尾插
p->next = s;

int temp = p->data;//交换数据域
p->data = s->data;
s->data = temp;
```

```python
LNode * p = GetElem(L,i-1);
LNode * temp = p->next;
p->next = temp->next;

temp->next = NULL;
free(temp)
temp = NULL;
```

```python
//通常做法是从头扫到该结点,每次保留扫描结点的前驱结点,那么找到该结点时就有了其前驱
//再执行删除操作;

//更好的方法是用其后驱,交换数据域,并删除其后驱
//注意：当后驱为NULL时交换再删除的方法不行，还是得老老实实
```

```python
//遍历一遍(记得单链表长度不包括头结点)
```

<h3 id="nJuv0">双链表：</h3>
有两个指针域,一个指向前驱,一个指向后驱;



```python
//要小心是不是结尾，否则会出现NULL->prior的问题（这东西根本不存在）
if(p->next != NULL){p->next->prior = s;}

s->next = p->next;
//等处理完原后驱结点相关的指向后才能改变p->next
p->next = s;
s->prior = p;
```

```python
p->prior->next = s;
s->prior = p->prior;
p->prior = s;
s->next = p;
```

```python
q=p->next;
q->next->prior = p;
p->next = q->next

free(q);
q = NULL;
```

```python
q = p->prior;
p->prior = q->prior;
q->prior->next = p;

free(q);
q = NULL;
```

<h3 id="bjwcj">循环链表：</h3>
:::info
<h4 id="EGNws">循环单链表：</h4>
**特点：最后一个结点的next域指向头结点；（判空条件为头结点next域指向的是否是头结点自身）**

:::

操作：

1.插入和删除：由于是环，插入和删除在每个位置（包括表尾）都等价，无需判断是否是表尾。

2.遍历：从哪个位置开始遍历都能遍历完整个表（环）

3.补充：有时对单链表的操作是在表头和表尾进行的，此时对于循环单链表，仅**<font style="color:#DF2A3F;">设尾指针</font>**就能满足（尾指针指向结点的next域就是头结点（连头指针都不需要了），因此对尾和头的操作都是O（1））

:::info
<h4 id="TanEP">循环双链表：</h4>
**特点：最后一个结点next域指向头结点，头结点的prior域指向最后结点；(循环双链表为空时，其头结点前驱与后继都是自己)**

:::

操作：

1.插入和删除：同理，每个位置的插入删除操作都是等价的；

2.遍历：任意一个位置都行

3.补充：设头/尾任一指针即可满足对表头和表尾操作（时间复杂度为O（1））

<h3 id="NG3So">静态链表：</h3>
用数组来描述链式存储结构

![](https://cdn.nlark.com/yuque/0/2024/png/25562551/1727592665831-403f063e-48c2-4f6d-9e2d-fd3c6af6f8f6.png)

:::info
特点：

1.需要预先分配一块连续的内存空间；

2.以next == -1 作为结束标志

:::

操作：（跟动态链表一样，操纵指针即可）



没有动态链表使用起来那么方便，但在有些语言不支持指针时可以这样用（如Basic）

<h3 id="nG7oZ"><font style="background-color:#FBDE28;">综合练习题：（感觉都是在指针上面做手脚）</font></h3>
+ **<font style="color:#DF2A3F;">编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小结点只有一个）：（有妙法）</font>**
    - 四个指针：遍历用的两个（一个指向现在结点，一个指前驱结点）记录用的两个（一个指向目前最小值结点，一个指向其前驱结点），扫描完一遍就可以删除了；

:::info
    - 拓展1：若没有头结点怎么办？（答：四个指针（两个遍历用,一个指向最小结点，一个指向最后结点的前驱）
    - 开头判断一下链表是否只有一个元素（L.next ==NULL是否成立）
    - 最小结点指针指向第一个元素，遍历的前驱指向第一个，现在结点指针指向第二个元素
    - 然后遍历，比较是否有更小的，若是则最小结点指向它。循环结束条件是目前结点是最后的元素（P->next == NULL）
    - 删除节点用交换前后数据域（也不是交换，就是后驱结点的值复制到前面结点）然后删除后驱。（当然要判断一下最小元素是否是最后一个结点（min->next == NULL），若是则用最后结点的前驱来删除）

:::

:::info
    - 拓展2：若最小结点有多个怎么办？
    - 只扫描一遍的方法：记录最小值同时若遇到相同值则记录起来（记录链表（数据域为指向不同结点最小值的指针），拥有指向头结点指针和指向最新的最小值记录结点的指针），若有更小的则从头开始一个个结点覆盖记录链表的数据域，同时改变指向最新的最小值记录的指针；
    - 时间复杂度O（n）,空间复杂度为O（m)(x<m<n,x为最小值的个数，n为链表长度)

:::

+ **<font style="color:#DF2A3F;">原地逆置一个带头结点的单链表：（有妙法）</font>**

:::info
    - 第一思路：三个指针，一个指针rev_end指向逆置链表的尾部，add_ptr一个指向当前要加入逆置链表的结点，next_ptr另一个指向其后驱。
    - 开始时，rev_end指向第一个元素，add_ptr指向第二个元素，next_ptr指向第三个元素，rev_end->next = NULL；
    - 循环直至next_ptr为空：add_ptr的后驱指向rev_end,将next_ptr赋值给add_ptr，next_ptr指向其指向结点的后驱
    - 最后将头结点后驱指向rev_end即可

:::

    - 书本解法1：把头结点摘下，从第一结点开始使用头插法，则逆序。
    - 书本解法2就是第一思路的做法
+ **<font style="color:#DF2A3F;">有一个带头结点的单链表L，设计算法使其元素递增有序</font>**<font style="color:#DF2A3F;">：</font><font style="color:#DF2A3F;background-color:#FBDE28;">（排序方面链表耗费大，需要使用数组辅助排序）</font>**<font style="color:#DF2A3F;">（暴力）</font>**

:::info
    - 暴力法：遍历一遍，各元素放入数组中排序，再根据数组创建新链表[时间复杂度O(Nlogn)，空间复杂度O（n）](PS:看了答案后这个第一想法反而是时间最优解，空间换时间)

:::

+ **<font style="color:#DF2A3F;">删除带头结点单链表中介于某个范围的值：（暴力）</font>**

:::info
    - 第一想法：遍历一遍就行，也不可能有更优解（时间复杂度O（n））

:::

+ **<font style="color:#DF2A3F;">给定两个单链表，找两个链表公共结点（有妙法）</font>**

:::info
    - 首先要知道什么是公共结点：<font style="color:rgb(0, 0, 0);">在第一链表和第二链表中都存在一个节点，该节点往后的子链表在两个链表中是相同的。</font>

:::

:::info
    - 最暴力法：O（n^2）,固定一个找另一个；

:::

:::info
    - 第二想法（如何利用公共结点特性呢？想到逆序）：将两个链表逆序（逆序时间复杂度O（n）），然后都从头遍历，直至出现两个指针指向结点不同，那他们的前驱就是公共结点。（时间复杂度O（n），若原地逆序则空间复杂度O(1)(原地逆序方法在上面)）

:::

:::info
    - 答案：扫描两个链表得出各自长度，他们的差为gap=|N1-N2|,对较长的链表扫描gap个元素后，两个链表一起扫描，直到找到相同结点/到链表结点（跟第二想法一样）

:::

+ **<font style="color:#DF2A3F;">按递增次序输出单链表各节点元素，并释放空间：（不允许使用数组作为辅助空间）（暴力）</font>**

:::info
    - 第一想法：仅用链表的话排序肯定是O（n^2）,每次扫描找最小值输出的做法也是O（n^2）
    - 若有更优法感觉应该往辅助空间上思考（但其他数据结构细节都忘部分了（大二学的），不敢用）
    - 答案：还真是O（n^2）

:::

+ **<font style="color:#DF2A3F;">假设有两个按元素值递增次序排序的线性表，均以单链表形式存储，编写算法将两个单链表归并为一个按元素值递减次序排序的单链表，要求利用原来两个单链表的结点存放归并后的单链表。（认识到在变更数组时头插逆序，不用排完再逆序）</font>**

:::info
    - 两个链表比较头部元素，数值低者用**头插法**插入新链表。

:::

+ 设计一个带头结点的循环单链表，结点值为正整数。设计一个算法，反复找出单链表中结点最小值进行输出并删除该节点，直到单链表为空，再删除头结点

:::info
    - 思路：暴力法，每次找最小值输出并删除，时间复杂度O（N^2）
    - 稍微优化：用一个结构体类型数组，存取最小值和对应链表地址，再添加一个指向链表倒数第二元素的指针。扫描链表一遍构建该数组并将指针指向倒数第二位，然后对数组进行排序，再按序输出，并删除对应地址链表（交换数据域并删除后驱的方法）。时间复杂度O(nlogn),空间复杂度O（n）

:::

+ **已知一个带有表头结点的单链表，结点结构为：data,link。假设该链表只给出头指针list。在不改变链表前提下，设计一个算法查找倒数第k个位置上的结点（k为正整数）。若查找成功输出该结点data域的值。**
+ **总结：（有固定距离关系的可以使用指针间隔k位后移动的思路）**

:::info
    - 第一思路：用数组辅助空间保存对应链表结点值（只扫描一遍，空间复杂度O（n））
    - 第二思路：用空间大小为k的数组，遍历链表时将值存在数组里，当数组满时从数组第一位重新开始存，链表遍历结束时数组最后保存的值的下一个值就是倒数第k位的值。（只扫描一遍，空间复杂度O（k））
    - 答案:用两个指针，一个工作指针，一个是指向倒数第k位的指针，当工作指针扫描到第k个位置时，两个指针开始一起向下一个结点移动，当工作指针扫描到末尾时，另一个指针指向位置即为倒数第k个位置（只扫描一遍，空间复杂度O（1），当时真想不到）

:::

+ 设计一个算法判断一个链表是否有环，如果有则找到环的入口点并返回，否则返回NULL；
+ <font style="color:#DF2A3F;background-color:#FBDE28;">新概念（快慢指针）</font>

:::info
    - 不会，直接看答案
    - 答案：快慢指针，一个指针每次只移动2个位置，一个只移动一个位置，当他们进入环后一定会在环上相遇。无环时遍历到最后会为空。

:::

+ 设线性表L=（a1,a2,a3...an）,采用带头结点的单链表保存，设计一个空间复杂度O（1）且时间上尽可能高效的算法，重新排列L中的各结点到线性表L‘=（a1,an,a2,an-1,a3,an-2...）;

:::info
    - 暴力法：两个指针，一个先固定，另一个扫描一遍，找到尾部结点插入到第一个指针的适当的位置（O（n^2））
    - 第二想法：两个指针：一个指针p1指第一位，一个工作指针p2，工作指针遍历到第(n-n/2(四舍五入)+1位置后，将后面的链表原地逆序，逆序完指针指的是an，此时接着两个指针一起遍历，将指针p2指向的结点插入到p1指向结点的后面，当p2指向空时停止。时间复杂度为O（n）

:::

+ 



<h2 id="bKztQ">顺序表和链表的比较：</h2>
<h3 id="CGa1V">1.存取方式：</h3>
顺序表：可以顺序存取，当然也可以随机存取；

链表：只能顺序存取



<h3 id="w0g3g">2.逻辑结构和物理结构：</h3>
顺序表：逻辑上相邻的元素，物理上也相邻；（顺序存储）

链表：逻辑上相邻，物理存储位置不一定相邻（随机存储）



<h3 id="UzWD3">3.查找、插入和删除：（顺序表查找快、链表更新耗费小）</h3>
<h4 id="MA7Vh">查找特定值：</h4>
顺序表：无序时为O（n）（遍历）、有序时为O(log2 n)

链表：O（n）

<h4 id="dPThb">按序号查找：</h4>
顺序表：O（1）

链表：O(n)



<h4 id="DKbW1">插入和删除：</h4>
顺序表：需要移动后续/前面的所有元素

链表：只需更改指针域即可



<h3 id="eQh8d">4.空间分配</h3>
<h4 id="MtHPW">顺序存储：</h4>
:::info
静态存储分配（a[maxsize]）：一旦存储空间装满就不能扩充，需要预先分配足够大的空间；

:::

:::info
动态存储分配(用指针指向一片区域)：可以扩充，但需要移动大量元素（另开一段连续空间），若内存中没有更大块的连续存储空间则会分配失败。

:::

<h4 id="HQj7X">链式存储：</h4>
申请时分配，只要内存还有空间就行。



<h2 id="k1rNO">存储结构的选择：</h2>
<h3 id="Ai6OX">1.存储方面的考虑：</h3>
事先不知道规模的最好选择链表；

<h3 id="uJpLu">2.运算/操作方面：</h3>
若频繁查找，最好是用顺序表；

若频繁更改表（插入、删除）：最好选择链表；若表规模不大的其实顺序表也可以忍受；



